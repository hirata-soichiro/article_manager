# プロダクト要求定義書（PRD）
## Article Manager - 技術記事管理システム

**バージョン:** 2.0.0（簡易版）
**作成日:** 2026-02-12
**更新日:** 2026-02-14
**対象:** 個人開発プロジェクト
**ステータス:** 実装済み

---

## 目次

1. [プロダクト概要](#1-プロダクト概要)
2. [主要機能](#2-主要機能)
3. [ユースケース](#3-ユースケース)
4. [機能要件詳細](#4-機能要件詳細)
5. [非機能要件](#5-非機能要件)
6. [セキュリティ要件](#6-セキュリティ要件)
7. [制約事項](#7-制約事項)
8. [将来の拡張性](#8-将来の拡張性)

---

## 1. プロダクト概要

### 1.1 プロダクト説明

Article Managerは、技術記事を効率的に管理・整理するための個人向けWebアプリケーションです。AI（Google Gemini）を活用して記事情報を自動抽出し、タグベースの分類と強力な検索機能で必要な情報に素早くアクセスできます。

### 1.2 解決する課題

- **情報の散逸**: ブラウザのブックマークでは記事が増えると管理が困難
- **手動入力の手間**: 記事情報を手動で入力する手間と時間
- **検索性の低さ**: 保存した記事を後から見つけることが困難
- **分類の困難さ**: 効果的なカテゴリ分けの仕組みがない
- **学習の非効率性**: 学んだ内容に関連する書籍を探す手間

### 1.3 プロダクトの価値提案

1. **AI自動入力**: URLを入力するだけで、記事のタイトル・要約・タグをAIが自動生成
2. **柔軟なタグ管理**: 複数タグによる柔軟な分類と絞り込み検索
3. **高速検索**: キーワードとタグによる強力な検索機能
4. **AI書籍推薦**: 保存した記事に基づいて関連書籍を自動推薦
5. **直感的なUI**: カード形式の見やすいデザインとレスポンシブ対応

### 1.4 開発目標

- 技術記事の管理時間を**50%削減**（現状2分 → 目標1分/記事）
- 保存した記事への再アクセスを容易にする
- AI技術を活用した自動化で手間を最小限に

---

## 2. 主要機能

### 2.1 コア機能

1. **記事管理機能**
   - 記事の作成・閲覧・編集・削除（CRUD操作）
   - URLからのAI自動生成
   - メモ機能

2. **タグ管理機能**
   - タグの作成・編集・削除
   - タグによる記事フィルタリング
   - タグの使用頻度表示

3. **検索機能**
   - キーワード検索（タイトル・要約）
   - タグフィルタリング
   - 複合検索（キーワード + タグ）

4. **AI機能**
   - 記事情報の自動生成（Google Gemini API）
   - 書籍推薦機能（保存記事に基づく）

### 2.2 技術スタック

**フロントエンド:**
- Next.js 15 (App Router)
- React 19
- TypeScript
- Tailwind CSS

**バックエンド:**
- Go 1.23
- Clean Architecture
- RESTful API

**データベース:**
- MySQL 8.0

**AI統合:**
- Google Gemini API（記事生成）
- Google Books API（書籍推薦）

---

## 3. ユースケース

### 3.1 日常的な利用シーン

#### シーン1: 朝の情報収集
```
目的: 通勤電車で読んだ技術記事を保存
頻度: 週5回（平日毎朝）

手順:
1. Qiita/Zennで記事を読む
2. Article ManagerにURLをコピー&ペースト
3. AIが自動でタイトル・要約・タグを生成（30秒）
4. 保存完了
```

#### シーン2: 開発中の調査
```
目的: バグ解決に役立った記事を保存
頻度: 週3回

手順:
1. Google検索で記事を発見
2. 問題が解決したらURLを保存
3. メモ欄に「〇〇のバグ解決に役立った」と記録
4. 関連タグ（例: "React", "エラー対応"）を確認
```

#### シーン3: 週末の復習
```
目的: 保存した記事を見返して知識定着
頻度: 週1回

手順:
1. タグ "React" で絞り込み
2. 今週保存した記事を閲覧
3. 重要な記事にメモを追加
4. AI書籍推薦から関連書籍を確認
```

### 3.2 主要ワークフロー

#### ワークフロー1: AI自動生成による記事保存
```
[記事発見] → [URLコピー] → [記事作成ボタン] → [URLペースト]
→ [AI生成ボタン] → [自動入力完了] → [確認・編集] → [保存]

所要時間: 30秒〜1分
```

#### ワークフロー2: 記事の検索と再閲覧
```
[検索ボックスに入力] → [検索結果表示] → [タグでさらに絞り込み]
→ [記事カードをクリック] → [記事詳細閲覧]

所要時間: 3秒〜10秒
```

---

## 4. 機能要件詳細

### 4.1 記事管理機能

#### 4.1.1 記事作成

**機能概要**: 新しい記事を手動またはAI支援で作成

**入力項目**:
- タイトル（必須、最大255文字）
- URL（必須、http/https形式）
- 要約（必須、最大1000文字）
- タグ（複数選択可能、各タグ最大50文字）
- メモ（任意、最大5000文字）

**処理フロー**:
1. ユーザーが「記事を作成」ボタンをクリック
2. フォーム画面を表示
3. 入力内容をバリデーション
4. APIに送信
5. 成功時: 記事一覧画面に遷移し、成功メッセージ表示
6. 失敗時: エラーメッセージ表示

**バリデーションルール**:
- タイトル: 空白不可、255文字以内
- URL: http/httpsで始まる有効なURL形式
- 要約: 空白不可、1000文字以内
- タグ: 各タグ50文字以内
- メモ: 5000文字以内

#### 4.1.2 AI自動生成

**機能概要**: URLを入力するだけで記事情報をAIが自動生成

**処理フロー**:
1. ユーザーがURLを入力
2. 「AIで生成」ボタンをクリック
3. Google Gemini APIにリクエスト送信
4. タイトル、要約、推奨タグを自動生成
5. フォームに自動入力
6. ユーザーは必要に応じて編集可能

**生成内容**:
- タイトル: 記事の主題を簡潔に表現
- 要約: 記事の内容を200-500文字で要約
- タグ: 3-5個の関連技術タグ

**エラーハンドリング**:
- URL取得失敗時: ユーザーに手動入力を促す
- AI生成失敗時: エラーメッセージとリトライオプション表示

#### 4.1.3 記事閲覧

**機能概要**: 保存された記事を一覧またはカード形式で閲覧

**表示情報**:
- タイトル
- 要約（省略表示）
- タグ一覧
- 作成日時
- 更新日時

**操作**:
- 記事カードをクリック: 詳細ページに遷移
- 編集ボタン: 編集画面に遷移
- 削除ボタン: 削除確認ダイアログ表示

**ページネーション**:
- デフォルト: 10件/ページ
- 選択可能: 10, 25, 50, 100件

#### 4.1.4 記事編集

**機能概要**: 既存記事の情報を更新

**処理フロー**:
1. 記事詳細画面から「編集」ボタンをクリック
2. 編集フォームに現在の情報を表示
3. ユーザーが情報を変更
4. バリデーション実行
5. APIに更新リクエスト送信
6. 成功時: 詳細画面に戻り、成功メッセージ表示

#### 4.1.5 記事削除

**機能概要**: 不要な記事を削除

**処理フロー**:
1. ユーザーが削除ボタンをクリック
2. 削除確認ダイアログ表示
3. 「削除する」をクリック
4. APIに削除リクエスト送信
5. 成功時: 記事一覧を更新し、成功メッセージ表示

**安全機能**:
- 削除確認ダイアログによる誤削除防止
- 削除操作は取り消し不可であることを明示

#### 4.1.6 エッジケースと例外処理

**ケース1: 同じURLの重複保存**
```yaml
動作:
  - 既存チェック: URLが既に存在するか検証
  - 処理:
    - 存在する場合: 警告ダイアログ表示
      「このURLは既に保存されています。既存の記事を開きますか？」
      [既存記事を開く] [それでも新規作成]
    - ユーザー選択に応じて処理
```

**ケース2: AI生成の部分的失敗**
```yaml
シナリオ: タイトルは生成できたが、要約生成に失敗

動作:
  - 成功した項目のみフォームに反映
  - 失敗した項目は空欄のまま
  - 警告メッセージ表示:
    「一部の情報を生成できませんでした。手動で入力してください。」
  - 再試行ボタン表示（失敗項目のみ再生成）
```

**ケース3: ネットワーク切断時の記事保存**
```yaml
動作:
  - 自動リトライ: 3回（5秒間隔）
  - 失敗時: ローカルストレージに一時保存
  - 通知: 「オフラインです。接続回復後に自動保存されます」
  - 再接続時: 自動的にサーバーへ送信
```

**ケース4: 不正なURL形式**
```yaml
検証:
  - 必須: http:// または https://
  - 許可: クエリパラメータ、ハッシュ
  - 禁止: javascript:, data:, file:

動作:
  - バリデーションエラー表示
  - 例: 「有効なURLを入力してください（http://またはhttps://で始まる）」
```

---

### 4.2 タグ管理機能

#### 4.2.1 タグ作成

**機能概要**: 新しいタグを作成

**入力項目**:
- タグ名（必須、最大50文字、空白のみ不可）

**バリデーション**:
- 空文字チェック
- 空白のみチェック
- 文字数上限チェック
- 重複チェック（大文字小文字を区別しない）

#### 4.2.2 タグ一覧表示

**機能概要**: 登録されているタグを一覧表示

**表示順序**: 記事数の多い順

**表示内容**:
- タグ名
- タグが付与されている記事数
- 作成日時

**制限**:
- デフォルト表示: 上位8個
- 「もっと見る」ボタンですべて展開可能

#### 4.2.3 タグフィルタリング

**機能概要**: 特定のタグを持つ記事のみを表示

**処理フロー**:
1. ユーザーがタグをクリック
2. 該当タグを持つ記事のみフィルタリング
3. 記事一覧を更新
4. フィルタ状態を視覚的に表示

**動作**:
- 複数タグの同時フィルタリング: 不可（単一タグのみ）
- 検索との併用: 可能（検索結果内でのタグフィルタ）

#### 4.2.4 タグ編集・削除

**編集機能**:
- タグ名の変更
- 変更は関連する全記事に即座に反映

**削除機能**:
- タグを削除
- 削除確認ダイアログ表示
- 削除時、記事からタグの関連付けも削除

#### 4.2.5 タグ管理のエッジケース

**ケース1: 重複タグ名の作成**
```yaml
検証: 大文字小文字を区別しない（"React" = "react"）

動作:
  - 作成前に重複チェック
  - 重複時: エラーメッセージ
    「"{タグ名}"は既に存在します」
  - 既存タグの使用を促す
```

**ケース2: 特殊文字を含むタグ名**
```yaml
入力例: "C++", "C#", "Vue.js"

許可:
  - 英数字
  - ハイフン (-)
  - ドット (.)
  - アンダースコア (_)
  - プラス (+)
  - シャープ (#)

禁止:
  - HTMLタグ記号 (<, >)
  - クォート (', ")
  - バックスラッシュ (\)
```

**ケース3: 使用中のタグを削除**
```yaml
動作:
  - 削除前に使用記事数を表示
  - 確認ダイアログ:
    「"{タグ名}"を削除すると、{N}件の記事からこのタグが削除されます。
     本当によろしいですか？」
  - 削除実行: カスケード削除（記事のtagsフィールドから除去）
```

---

### 4.3 検索機能

#### 4.3.1 キーワード検索

**機能概要**: タイトルまたは要約にキーワードを含む記事を検索

**検索対象**:
- 記事タイトル
- 記事要約

**検索方式**:
- 部分一致検索
- 大文字小文字を区別しない

**デバウンス**:
- 入力後300-500ms待機してからAPI呼び出し
- 入力中の無駄なAPI呼び出しを削減

**検索結果表示**:
- マッチした記事数を表示
- 検索キーワードを表示
- 「検索をクリア」ボタン表示

#### 4.3.2 タグとの複合検索

**機能概要**: キーワード検索結果をさらにタグでフィルタリング

**処理フロー**:
1. キーワード検索を実行
2. 検索結果内でタグフィルタを適用
3. 絞り込まれた結果を表示

#### 4.3.3 検索機能のエッジケース

**ケース1: 検索結果0件**
```yaml
動作:
  - 空状態画面表示
  - メッセージ: 「"{キーワード}"に一致する記事が見つかりません」
  - サジェスション:
    - 「別のキーワードで検索してみてください」
    - 「検索をクリア」ボタン
```

**ケース2: 特殊文字を含む検索**
```yaml
入力例: "C++", "React.js", "Go<3.0"

動作:
  - エスケープ処理: SQLインジェクション対策
  - 特殊文字を含めたまま検索実行
  - 注意: ワイルドカード（*、%）は無効化
```

**ケース3: 極端に長い検索キーワード**
```yaml
制限: 最大200文字

動作:
  - 超過時: 200文字で切り捨て
  - 警告表示: 「検索キーワードが長すぎます（最大200文字）」
```

---

### 4.4 書籍推薦機能

#### 4.4.1 AI書籍推薦

**機能概要**: 保存した記事に基づいて関連書籍をAI推薦

**処理フロー**:
1. ユーザーが記事一覧ページにアクセス
2. 保存されている記事を分析
3. Google Gemini APIで関連書籍を推薦
4. Amazon、楽天の購入リンクを生成
5. 推薦結果を表示

**推薦内容**:
- 書籍タイトル
- Amazon購入リンク
- 楽天ブックス購入リンク

**キャッシュ機能**:
- 生成された推薦結果を24時間キャッシュ
- キャッシュ期限内は再生成しない
- パフォーマンス向上とAPI利用コスト削減

**表示位置**: 記事一覧ページの上部

#### 4.4.2 書籍推薦機能のエッジケース

**ケース1: 記事数が少なすぎる（0-2記事）**
```yaml
動作:
  - 推薦機能を非表示
  - または: 汎用的な技術書を推薦
    「まだ記事が少ないため、一般的なおすすめ書籍を表示しています」
```

**ケース2: Gemini API呼び出し失敗**
```yaml
原因: APIダウン、クォータ超過、タイムアウト

動作:
  - 自動リトライ: 2回（5秒、10秒後）
  - 失敗時: セクション非表示
  - ログ記録: エラー詳細を記録
  - ユーザー通知: なし（書籍推薦はオプショナル機能）
```

---

## 5. 非機能要件

### 5.1 パフォーマンス要件

| 項目 | 要件 |
|------|------|
| ページ読み込み時間 | 初回3秒以内、2回目以降1秒以内 |
| API応答時間 | 90%のリクエストで500ms以内 |
| AI生成時間 | 10秒以内 |
| データベースクエリ | 100ms以内 |

### 5.2 拡張性要件

- **記事数**: 10,000記事まで対応
- **タグ数**: 1,000タグまで対応

### 5.3 ユーザビリティ要件

- **学習時間**: 初回利用から5分以内に主要機能を使用可能
- **操作性**: 記事保存は3クリック以内
- **レスポンシブ**: スマートフォン、タブレット、デスクトップ対応

### 5.4 互換性要件

**ブラウザ対応**:
- Chrome 最新版
- Firefox 最新版
- Safari 最新版
- Edge 最新版

**画面解像度**:
- モバイル: 375px以上
- タブレット: 768px以上
- デスクトップ: 1024px以上

### 5.5 保守性要件

- **コード品質**: テストカバレッジ70%以上
- **ドキュメント**: API仕様書、アーキテクチャドキュメント必須
- **ログ**: エラーログ、アクセスログを記録

---

**技術仕様、API設計、データモデル、UI設計の詳細は以下のドキュメントを参照してください:**
- **技術仕様**: `docs/architecture.md`
- **API設計・データモデル・UI設計**: `docs/functional-design.md`

---

## 6. セキュリティ要件

### 6.1 セキュリティリスク評価（個人開発版）

**現在の最大リスク: 認証機能の不在**

| リスク | 重大度 | 対策 |
|--------|--------|------|
| 不正アクセス（誰でもデータ参照可能） | 🔴 Critical | ローカル環境での運用 / 早期認証実装 |
| データ改ざん（誰でも記事削除可能） | 🔴 Critical | ローカル環境での運用 / バックアップ |
| API キー漏洩（Gemini API） | 🟡 High | 環境変数管理、定期ローテーション |
| SQLインジェクション | 🟢 Low | プリペアドステートメント使用中 |

**個人開発での運用方針:**
- Phase 1（現在）: ローカル環境またはVPN経由のアクセスのみ
- Phase 2（3ヶ月以内）: JWT認証の実装

### 6.2 データ保護

#### 6.2.1 入力バリデーション

**フロントエンド（クライアント側）**:
```yaml
バリデーション:
  - リアルタイムフィードバック
  - 文字数制限の視覚化
  - 不正な文字の即時検出

制限:
  - タイトル: 1-255文字、制御文字禁止
  - URL: http/https必須、最大2048文字
  - 要約: 1-1000文字
  - タグ: 1-50文字/個、特殊文字禁止（<>"'など）
  - メモ: 最大5000文字
```

**バックエンド（サーバー側）**:
```yaml
バリデーション（二重チェック）:
  1. Null/空文字チェック
  2. 文字数範囲チェック
  3. 形式チェック（URL、文字種）
  4. サニタイゼーション
     - HTMLタグ除去（要約、メモ）
     - SQLメタ文字エスケープ（プリペアドステートメント使用）
     - スクリプトタグ除去
```

#### 6.2.2 SQLインジェクション対策

```yaml
実装済み対策:
  ✅ プリペアドステートメント（sqlx）
  ✅ ORMによるクエリビルド

追加対策:
  - 動的クエリの禁止
  - DB権限の最小化
```

#### 6.2.3 XSS（クロスサイトスクリプティング）対策

```yaml
フロントエンド:
  ✅ React自動エスケープ（デフォルト動作）
  ⚠️ dangerouslySetInnerHTML使用禁止
  ✅ URLのサニタイゼーション（https://のみ許可）

追加対策:
  - Content Security Policy (CSP) ヘッダー設定
```

### 6.3 通信セキュリティ

#### 6.3.1 HTTPS/TLS

```yaml
本番環境:
  - TLS 1.2以上必須（TLS 1.3推奨）
  - 証明書: Let's Encrypt自動更新
  - HTTP自動リダイレクト: HTTP→HTTPS

開発環境:
  - HTTPを許可（ローカル開発のみ）
```

#### 6.3.2 CORS（Cross-Origin Resource Sharing）

```yaml
設定:
  許可オリジン:
    - http://localhost:3000 (開発)
    - 本番環境の特定ドメインのみ

  許可メソッド: GET, POST, PUT, DELETE, OPTIONS
  許可ヘッダー: Content-Type, Authorization
```

### 6.4 APIセキュリティ

#### 6.4.1 APIキー管理

```yaml
Gemini APIキー:
  保存場所:
    - 開発: .env（Gitignore済み）
    - 本番: 環境変数

  ローテーション:
    - 頻度: 90日ごと

  漏洩時の対応:
    1. 即座にAPIキー無効化
    2. 新規キー発行
    3. 全環境にデプロイ
    4. 利用ログ確認（不正利用の有無）
```

#### 6.4.2 API応答のセキュリティ

```yaml
ヘッダー設定:
  - X-Content-Type-Options: nosniff
  - X-Frame-Options: DENY
  - X-XSS-Protection: 1; mode=block
  - Referrer-Policy: strict-origin-when-cross-origin

エラーレスポンス:
  - 内部エラーの詳細を隠蔽
  - スタックトレース非表示（本番）
  - 一般的なエラーメッセージ
```

### 6.5 認証・認可（Phase 2実装予定）

#### 6.5.1 認証方式

```yaml
Phase 2実装:
  方式: JWT (JSON Web Token)

  トークン仕様:
    - アルゴリズム: RS256 (非対称鍵)
    - 有効期限:
      - Access Token: 1時間
      - Refresh Token: 30日

  パスワード:
    - ハッシュ: bcrypt（cost=12）
    - 最小長: 12文字
    - 複雑度: 大小英数字+記号
```

---

## 7. 制約事項

### 7.1 技術的制約

1. **シングルユーザー**: 現バージョンは複数ユーザーに対応していない
2. **認証なし**: ユーザー認証機能が未実装（Phase 1）
3. **ファイルアップロード**: 画像などのファイルアップロード機能なし
4. **記事の本文保存**: 記事全文は保存せず、要約とリンクのみ

### 7.2 外部依存

1. **Google Gemini API**: API利用料金が発生
2. **Google Books API**: API制限あり
3. **外部記事URL**: 元記事が削除されるとアクセス不可

### 7.3 データ制約

1. **タイトル長**: 最大255文字
2. **要約長**: 最大1000文字
3. **メモ長**: 最大5000文字
4. **タグ名長**: 最大50文字
5. **記事あたりタグ数**: 推奨5個以内（制限なし）
6. **総記事数**: 10,000記事まで
7. **総タグ数**: 1,000タグまで

### 7.4 運用制約

1. **バックアップ**: 手動でのDBバックアップが推奨
2. **監視**: アプリケーション監視ツール未導入
3. **ログ管理**: ログローテーション設定が必要

---

## 8. 将来の拡張性

### 8.1 短期（3-6ヶ月）

1. **ユーザー認証機能**
   - JWT認証の実装
   - ユーザー登録・ログイン機能
   - パスワードリセット機能

2. **記事の公開・共有機能**
   - 記事の公開/非公開設定
   - 共有用URLの生成
   - SNSシェア機能

3. **タグの階層化**
   - 親子関係を持つタグ
   - タグのグループ化

### 8.2 中期（6-12ヶ月）

1. **マルチユーザー対応**
   - 組織・チーム機能
   - 記事の共有・コラボレーション
   - アクセス権限管理

2. **高度な検索機能**
   - 全文検索エンジン（Elasticsearch）導入
   - ファセット検索
   - 検索履歴

3. **記事の自動分類**
   - 機械学習によるタグ自動提案
   - 関連記事の自動推薦
   - トピッククラスタリング

### 8.3 長期（12ヶ月以上）

1. **学習管理機能**
   - 読んだ記事の進捗管理
   - 学習パスの作成
   - 習熟度トラッキング

2. **ソーシャル機能**
   - ユーザー間のフォロー機能
   - 記事のいいね・コメント
   - キュレーションリスト

3. **統合機能**
   - Slack/Discord連携
   - GitHub連携
   - Notion/Evernote連携
   - ブラウザ拡張機能

4. **モバイルアプリ**
   - iOS/Androidネイティブアプリ
   - オフライン閲覧
   - プッシュ通知

5. **高度なAI機能**
   - 記事内容の要約精度向上
   - 質問応答機能（記事を元にした回答生成）
   - パーソナライズされた学習推薦

---

## 変更履歴

| バージョン | 日付 | 変更内容 |
|-----------|------|---------|
| 2.0.0 | 2026-02-14 | 個人開発向けに簡略化。市場分析、ビジネスモデル、詳細なペルソナ、リスク管理のSWOT分析を削除 |
| 1.0.0 | 2026-02-12 | 初版作成 |

---

## 関連ドキュメント

- **技術仕様書**: `docs/architecture.md`
- **機能設計書**: `docs/functional-design.md`
- **リポジトリ構造定義書**: `docs/repository-structure.md`
- **開発ガイドライン**: `docs/development-guidelines.md`
- **ユビキタス言語定義**: `docs/glossary.md`
